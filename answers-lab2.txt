Question
1.Assuming that the following JOS kernel code is correct,what type should variable x have, uintptr_t or physaddr_t?
	mystery_t x;
	char* value = return_a_pointer();
	*value = 10;
	x = (mystery_t) value;

A: 内核中的操作已经是虚地址下的了，且value指针可以解引用，x应该是uintptr_t。

2. What entries (rows) in the page directory have been filled in at this point? What addresses do they map and where do they point? In other words, fill out this table as much as possible:

A: 
Entry	Base Virtual Addr	Points to (logically):
1023	0xffc0000		page table for top 4MB of phys memory  
1022	0xff80000		page table for top 4MB~8MB phys memory  
	

960	0xf0000000	page table for kernel code(KERNBASE) 
959	0xefc00000	kernel data top(KSTACKTOP) 
			[KSTACKTOP-KSTKSIZE, KSTACKTOP) = [efbf8000, efc00000) are bootstack
958	0xef800000	page table (ULIM)
			[ef400000, ef800000) are current page table
957	0xef400000	pages space max position(UVPT)
			[ef000000, ef400000) are Page[]
956	0xef000000	pages space min position(UPAGES)
			[eec00000, ef000000) are read-only envs
955	0xeec00000	User exception stack limit position(high)(UTOP)
	0xeebff000	User exception stack limit position(low)
	0xeebfe000	User stack limit position(high)(USTACKTOP)
	0xeebfd000	User stack limit position(low)



3. (From Lecture 3) We have placed the kernel and user environment in the same address space. Why will user programs not be able to read or write the kernel's memory? What specific mechanisms protect the kernel memory?

A: 在页表中entry的后几位（段式时为段的后几位）能表示该页（段）的访问权限，从而将这块内存的使用保护起来。

4. What is the maximum amount of physical memory that this operating system can support? Why?

A: 一个Page所占8位空间，而存放Page在UPAGES有PTSIZE（4M）的大小，能存放512K的Page，即可以管理2G的物理内存。

5. How much space overhead is there for managing memory, if we actually had the maximum amount of physical memory? How is this overhead broken down?

A: 其中有4M用作储存Page的内容，另外4K作为Page Directory，另外一部分作为Page Table，最多虚拟内存视作有1K个页表，每个页表4K大小，总共4M+4K+4M = 8M+8K。
减少overhead可以使用大页表，一个Page Directory的entry直接表示一个4M的页，这样就不需要另外的1K个4K大小的页表了。

6. Revisit the page table setup in kern/entry.S and kern/entrypgdir.c. Immediately after we turn on paging, EIP is still a low number (a little over 1MB). At what point do we transition to running at an EIP above KERNBASE? What makes it possible for us to continue executing at a low EIP between when we enable paging and when we begin running at an EIP above KERNBASE? Why is this transition necessary?

A: 在entry.S中的第66、67行，利用跳转实现了eip值的变化。这里因为同时将[0,4M)和[KERNBASE, KERNBASE + 4M)的虚拟地址都映射到相同的物理地址，因而保证了跳转后代码正好可以继续执行。这里的转换是因为设计中内核代码运行在高地址，而且之后会变化寻址方式，而如果不跳转则后面会发生寻址错误。

Challenge1: 
showmappings通过输入虚拟地址区间左右边界，通过调用pgdir_walk来输出页面的映射信息。
setmapping通过输入虚拟地址、大小、物理地址、权限符号，调用page_insert来增加映射。
dumpmem通过输入虚/实地址表示位和地址区间左右边界，输出地址内容。

实际实现中。